# -*- coding: utf-8 -*-
"""animation.ipynb

Automatically generated by Colab.

"""

import pandas as pd
import numpy as np
import json
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import ticker, cm
import matplotlib.colors as colors
import math
import time
from IPython import display
import matplotlib.animation as animation
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms
from matplotlib.colors import LinearSegmentedColormap
from scipy import stats

def get_ellipse(center: np.ndarray, cova: np.ndarray, nsigma: int = 1, npoints: int = 1000) -> np.ndarray:
    cholesky_l = np.linalg.cholesky(cova)
    t = np.linspace(0, 2 * np.pi, npoints)
    circle = np.column_stack([np.cos(t), np.sin(t)])
    ellipse = nsigma * circle @ cholesky_l.T + center
    return ellipse.T

from google.colab import drive
drive.mount('/content/drive')

dim_co = dim_int = 1
dim = 2

def sphere(x):
    tmp = np.array(x)
    tmp = tmp.reshape(-1)
    return np.sum(tmp**2)

def reversed_ellipsoid_int(x):
  #np.round(x)
  y = x.copy()
  coefficients = np.array([math.pow(1e3, i / (dim - 1.)) for i in range(dim)]).reshape(-1, 1)
  return np.sum((coefficients[dim_co:] * y[:dim_co])**2) + np.sum((coefficients[:dim_co] * y[dim_co:])**2)

def ellipsoid_int(x):
  y = x.copy()
  coefficients = np.array([math.pow(1e3, i / (dim - 1.)) for i in range(dim)]).reshape(-1,1)
  return np.sum((coefficients * y)**2)

def different_powers(x):
        xbar = np.array(x)
        xbar = np.abs(xbar)
        xbar[dim_co:] = np.round(xbar[dim_co:])
        power = np.array([2 + 4 * i / (dim - 1.) for i in range(dim)]).reshape(-1, 1)
        return np.sum(np.power(xbar, power))

def n_int_tablet(x):
        xbar = np.array(x)
        xbar[dim_co:] = np.round(xbar[dim_co:])
        xbar[:dim_co] *= 100
        return np.sum(xbar**2)

def sphere_int(x):
        xbar = np.array(x)
        xbar[dim_co:] = np.round(xbar[dim_co:])
        return np.sum(xbar**2)

def rastrigin(x):
            y = x.copy()
            np.round(y[dim_co:])
            return 10*dim + np.sum([y[i] ** 2 - 10.0 * math.cos(2.0 * math.pi * y[i]) for i in range(dim)])

def get_ellipse(mean, cov, nsigma=1):
    eigvals, eigvecs = np.linalg.eigh(cov)
    order = eigvals.argsort()[::-1]
    eigvals, eigvecs = eigvals[order], eigvecs[:, order]
    theta = np.degrees(np.arctan2(*eigvecs[:, 0][::-1]))
    width, height = 2 * nsigma * np.sqrt(eigvals)
    return mean, width, height, theta

def other_animate(step=1, max_frame=51, distribution=True):
    with open('reversed_ellipsoid_int.json', 'r') as f:
        data = json.load(f)

    all_mean = data['root']['all_mean']
    pop = data['root']['all_inds']
    std = data['root']['all_std']
    domain = [-4, 10]
    X = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)
    Y = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)
    #Y = np.round(Y[:])
    #print('X: ', X)
    #print('Y: ', Y)

    X, Y = np.meshgrid(X, Y)
    Z = np.array([[reversed_ellipsoid_int([xx, np.round(yy)]) for xx, yy in zip(x, y)] for x, y in zip(X, Y)])
    #print('Z: ', Z)

    minima = (0, 0)
    fig, ax = plt.subplots()
    ax.set_title('STD: \n Iteration: ')
    ax.set_xlabel("X0")
    ax.set_ylabel("X1")

    bg = ax.contourf(Z, extent=[domain[0], domain[1], domain[0], domain[1]], origin='lower', cmap='viridis', alpha=0.9)
    fig.colorbar(bg, ax=ax)

    ax.plot(minima[0], minima[1], 'r*', markersize=15)

    ellipse = Ellipse((0, 0), 0, 0, fill=False, linestyle='--', edgecolor='white')
    ax.add_patch(ellipse)

    ellip_center = ax.scatter([], [], color='white')

    def update(i):
        X1 = pop[i * step][0]
        X2 = pop[i * step][1]
        mean = [np.mean(X1), np.mean(X2)]
        cov = np.cov(X1, X2)

        center, width, height, theta = get_ellipse(mean, cov, nsigma=1)
        ellipse.set_center(center)
        ellipse.width = width
        ellipse.height = height
        ellipse.angle = theta

        ellip_center.set_offsets(center)

        #ax.set_title(f'STD: {std[i]} \n Iteration: {i}')
        ax.set_title(f'Iteration: {i}')

    anim = animation.FuncAnimation(fig, update, frames=max_frame // step, blit=False, interval=250)
    plt.close(fig)

    return anim

anim = other_animate(1, 68, True)
anim.save('/content/drive/MyDrive/Research/Code/KLTN/demo.gif')
##########################################################################################
# Track full
def get_ellipse(mean, cov, nsigma=1):
    eigvals, eigvecs = np.linalg.eigh(cov)
    order = eigvals.argsort()[::-1]
    eigvals, eigvecs = eigvals[order], eigvecs[:, order]
    theta = np.degrees(np.arctan2(*eigvecs[:, 0][::-1]))
    width, height = 2 * nsigma * np.sqrt(eigvals)
    return mean, width, height, theta

def other_animate(step=1, max_frame=51, distribution=True):
    with open('sphere.json', 'r') as f:
        data = json.load(f)

    all_mean = data['root']['all_mean']
    pop = data['root']['all_inds']
    std = data['root']['all_std']
    v = data['root']['all_v']
    domain = [-4, 10]
    X = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)
    Y = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)
    #Y = np.round(Y[:])
    #print('X: ', X)
    #print('Y: ', Y)

    X, Y = np.meshgrid(X, Y)
    Z = np.array([[sphere([xx, yy]) for xx, yy in zip(x, y)] for x, y in zip(X, Y)])
    #print('Z: ', Z)
    #Z = np.array([[reversed_ellipsoid_int([xx, 0]) for xx in x] for x in X])

    minima = (0, 0)
    fig, ax = plt.subplots()
    ax.set_title('STD: \n Iteration: ')
    ax.set_xlabel("X0")
    ax.set_ylabel("X1")

    bg = ax.contourf(Z, extent=[domain[0], domain[1], domain[0], domain[1]], origin='lower', cmap='viridis', alpha=0.9)
    fig.colorbar(bg, ax=ax)

    ax.plot(minima[0], minima[1], 'r*', markersize=15)

    ellipse = Ellipse((0, 0), 0, 0, fill=False, linestyle='--', edgecolor='white')
    ax.add_patch(ellipse)

    ellip_center = ax.scatter([], [], color='white')
    velocity_points = ax.scatter([], [], color='red', s=10, label='(V1, V2)')
    arrow = None

    def update(i):
        nonlocal arrow
        if arrow:
            arrow.remove()
        X1 = pop[i * step][0]
        X2 = pop[i * step][1]
        V1 = v[i * step][0]
        V2 = v[i * step][1]
        mean = [np.mean(X1), np.mean(X2)]
        cov = np.cov(X1, X2)

        center, width, height, theta = get_ellipse(mean, cov, nsigma=1)
        ellipse.set_center(center)
        ellipse.width = width
        ellipse.height = height
        ellipse.angle = theta

        ellip_center.set_offsets(center)
        velocity_points.set_offsets(np.c_[V1, V2])

        dx = V1 - center[0]
        dy = V2 - center[1]
        arrow = ax.arrow(center[0], center[1], dx, dy, color='blue', head_width=0.2, length_includes_head=True)

        ax.set_title(f'STD: {std[i]} \n Iteration: {i}')

    anim = animation.FuncAnimation(fig, update, frames=max_frame // step, blit=False, interval=350)
    plt.close(fig)

    return anim

anim = other_animate(1, 41, True)
anim.save('/content/drive/MyDrive/Research/Code/KLTN/ori_sphere.gif')
##########################################################################################
# Track unit
def get_ellipse(mean, cov, nsigma=1):
    eigvals, eigvecs = np.linalg.eigh(cov)
    order = eigvals.argsort()[::-1]
    eigvals, eigvecs = eigvals[order], eigvecs[:, order]
    theta = np.degrees(np.arctan2(*eigvecs[:, 0][::-1]))
    width, height = 2 * nsigma * np.sqrt(eigvals)
    return mean, width, height, theta

def other_animate(step=1, max_frame=51, distribution=True):
    with open('track_ellipsoid_int.json', 'r') as f:
        data = json.load(f)

    all_mean = data['root']['all_mean']
    pop = data['root']['all_inds']
    std = data['root']['all_std']
    v = data['root']['all_v']
    domain = [-6, 15]
    X = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)
    Y = np.arange(domain[0], domain[1], (domain[1] - domain[0]) / 100)

    X, Y = np.meshgrid(X, Y)
    Z = np.array([[ellipsoid_int([xx, np.round(yy)]) for xx, yy in zip(x, y)] for x, y in zip(X, Y)])

    minima = (0, 0)
    fig, ax = plt.subplots()
    ax.set_title('STD: \n Iteration: ')
    ax.set_xlabel("X0")
    ax.set_ylabel("X1")

    bg = ax.contourf(Z, extent=[domain[0], domain[1], domain[0], domain[1]], origin='lower', cmap='viridis', alpha=0.9)
    fig.colorbar(bg, ax=ax)

    ax.plot(minima[0], minima[1], 'r*', markersize=15)

    ellipse = Ellipse((0, 0), 0, 0, fill=False, linestyle='--', edgecolor='white')
    ax.add_patch(ellipse)

    ellip_center = ax.scatter([], [], color='white')
    arrow = None

    def update(i):
        nonlocal arrow
        if arrow:
            arrow.remove()

        X1 = pop[i * step][0]
        X2 = pop[i * step][1]
        V1 = v[i * step][0]
        V2 = v[i * step][1]
        mean = [np.mean(X1), np.mean(X2)]
        cov = np.cov(X1, X2)

        center, width, height, theta = get_ellipse(mean, cov, nsigma=1)
        ellipse.set_center(center)
        ellipse.width = width
        ellipse.height = height
        ellipse.angle = theta

        ellip_center.set_offsets(center)

        dx = V1 - center[0]
        dy = V2 - center[1]
        magnitude = np.sqrt(dx**2 + dy**2)
        if magnitude != 0:
            dx /= magnitude
            dy /= magnitude

        arrow = ax.arrow(center[0], center[1], dx, dy, color='blue', head_width=0.2, length_includes_head=True)

        ax.set_title(f'STD: {std[i]} \n Iteration: {i}')

    anim = animation.FuncAnimation(fig, update, frames=max_frame // step, blit=False, interval=350)
    plt.close(fig)

    return anim

anim = other_animate(1, 32, True)
anim.save('/content/drive/MyDrive/Research/Code/KLTN/track.gif')