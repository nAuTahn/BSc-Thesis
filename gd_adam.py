# -*- coding: utf-8 -*-
"""gd_adam.ipynb

Automatically generated by Colab.

"""

import numpy as np
from bisect import bisect_left
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

bounds = np.array([[-5.0, 5.0], [-5.0, 5.0]])

def transform(x):
  domain_int = [list(range(-5, 6))]
  domain_int[0].sort()
  #print(domain_int[0])
  lim = [[(domain_int[0][j] + domain_int[0][j + 1]) / 2. for j in range(len(domain_int[0]) - 1)]]
  xbar = domain_int[0][bisect_left(lim[0], x)]
  return xbar

def objective(x, y):
    return x ** 2.00 + np.round(y) ** 2.00

def derivative(x, y):
    return np.array([2.0 * x, 2.0 * y])

def objective2(x, y):
  x = np.clip(x, -5, 5)
  y = np.clip(y, -5, 5)
  return x**2.0 + (np.round(y) * 1000)**2.0

def derivative2(x, y):
    x = np.clip(x, -5, 5)
    y = np.clip(y, -5, 5)
    return np.array([2.0 * x, 2.0 * 1000 * y])

def gradient_descent2(objective, derivative, bounds, n_iter, alpha, eps=1e-8):
    x = bounds[:, 0] + np.random.rand(len(bounds)) * (bounds[:, 1] - bounds[:, 0])
    scores = []
    trajectory = []

    for t in range(n_iter):
        g = derivative(x[0], x[1])

        for i in range(x.shape[0]):
            x[i] = x[i] - alpha * g[i]

        score = objective(x[0], np.round(x[1]))
        scores.append(score)
        trajectory.append(x.copy())

    print(f'iter:    {t - 1}')

    return x, scores, trajectory

def adam(objective, derivative, bounds, n_iter, alpha, beta1, beta2, eps=1e-8):
    x = bounds[:, 0] + np.random.rand(len(bounds))\
    * (bounds[:, 1] - bounds[:, 0])
    scores = []
    trajectory = []

    m = np.zeros(bounds.shape[0])
    v = np.zeros(bounds.shape[0])

    for t in range(n_iter):
        g = derivative(x[0], x[1])

        for i in range(x.shape[0]):
            m[i] = beta1 * m[i] + (1.0 - beta1) * g[i]
            v[i] = beta2 * v[i] + (1.0 - beta2) * g[i] ** 2
            mhat = m[i] / (1.0 - beta1 ** (t + 1))
            vhat = v[i] / (1.0 - beta2 ** (t + 1))
            x[i] = x[i] - alpha * mhat / (np.sqrt(vhat) + eps)

        score = objective(x[0], transform(x[1]))
        scores.append(score)
        trajectory.append(x.copy())

    print(f'iter:    {t - 1}')

    return x, scores, trajectory
############################################################################################
############################################################################################
n_iter = 500
alpha = 0.02
beta1 = 0.8
beta2 = 0.999

best, scores, trajectory = adam(objective, derivative,
                                bounds, n_iter, alpha,
                                beta1, beta2)
#print(f'best:    {best}')
#print(scores)
#print(f'value: {objective2(best[0], best[1])}')

x = np.linspace(bounds[0, 0], bounds[0, 1], 100)
y = np.linspace(bounds[1, 0], bounds[1, 1], 100)
X, Y = np.meshgrid(x, y)
Z = objective(X, Y)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.5)
ax.scatter(best[0], best[1], objective(best[0], best[1]),
           color='red', label='Best')
ax.plot([point[0] for point in trajectory],
        [point[1] for point in trajectory], scores,
        color='blue', label='Trajectory')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Objective')
ax.legend()

plt.savefig('3D_adam.png', bbox_inches='tight')
plt.show()
############################################################################################
############################################################################################
n_iter = 500
alpha = 0.002
bounds = np.array([[-5, 5], [-5, 5]])

best, scores, trajectory = gradient_descent2(objective, derivative,
                                           bounds, n_iter, alpha)

print(f'best:    {best}')
#print(scores)
print(f'value: {objective2(best[0], best[1])}')

x = np.linspace(bounds[0, 0], bounds[0, 1], 100)
y = np.linspace(bounds[1, 0], bounds[1, 1], 100)
X, Y = np.meshgrid(x, y)
Z = objective(X, Y)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.5)
ax.scatter(best[0], best[1], objective(best[0], best[1]),
           color='red', label='Best')
ax.plot([point[0] for point in trajectory],
        [point[1] for point in trajectory], scores,
        color='blue', label='Trajectory')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Objective')
ax.legend()

plt.savefig('3D_gradient_descent.png', bbox_inches='tight')
plt.show()

